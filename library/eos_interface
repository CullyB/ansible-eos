#!/usr/bin/python
#
# Copyright (c) 2014, Arista Networks, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#   Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
#   Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
#   Neither the name of Arista Networks nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ARISTA NETWORKS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
DOCUMENTATION = """
module: eos_interface
short_description: Manage interfaces in EOS
description:
  - Provides active state management of physical ethernet interfaces
    configuration on Arista EOS nodes. All configuration of
    resources is idempotent unless otherwise specified.
author: Arista EOS+
notes:
requirements:
  - Arista EOS 4.12.0 or later
  - EOS command API enabled
options:
  name:
    description:
      - Provides an arbitrary named description for this interface.  If
        the interface parameter is not set, then the name value is used
        as the interface to configure.
    required: true
    aliases: []
  interface:
    description:
      - The unique interface identifier name.  The interface name must use
        the full interface name (no abbreviated names).  For example,
        interfaces should be specified as Ethernet1 not Et1
    required: false
    aliases: ['intfid']
  admin:
    description:
      - Configures the administrative state for the interface.  Valid
        values include enable and disable.
    required: false
    default: null
    choices: ['enable', 'disable']
    aliases: []
  description:
    description:
      - Sets a one line ASCII description for the interface.
    required: false
    aliases: []
  null_as_default:
    description:
      - Instructs the module how to handle null values.  If this flag is set
        then null values trigger default configuration otherwise do nothing
    required: false
    default: false
    choices: [true, false]
    aliases: []
  state:
    description:
      - Identifies the state of the interface.  Interfaces can be either
        configured, unconfigured or default.   Please beware that an interface with
        state of default will also wipe out any additional services
        on top of the physical interface.
    required: false
    default: configured
    choices: ['configured', 'unconfigured', 'default']
    aliases: []
  eapi_hostname:
    description:
      - The IP address or DNS hostname of the EOS device to be managed.  If
        local_connection is used, then this value must be configured.  When
        not using local_connection, this value does not need to be supplied
        and defaults to 'localhost'
    required: false
    default: 'localhost'
    aliases: []
  eapi_username:
    description:
      - The username to use for calls to eAPI.  If the username is not
        specified, then the default is used
    required: false
    default: 'admin'
    alias: []
  eapi_password:
    description:
      - The password to use for calls to eAPI.  If the password is not
        specified then the default is used ('')
    required: false
    default: ''
    alias: []
  eapi_enable_password:
    description:
      - The enable password to use for calls to eAPI.  If the enable
        password is not specified then the default is used ('')
    required: false
    default: ''
    alias: []
  eapi_protocol:
    description:
      - Configures the transport for connection to eAPI for either local
        or remote connections.  This value should be the same as shown
        from the output of 'show management api http-commands'
    require: false
    default: 'https'
    choices: ['http', 'https']
    alias: []
  eapi_port:
    description:
      - Configures the port used ifor connecting to eAPI for either local
        or remote connections.  This value should be the same as shown
        from the output of 'show management api http-commands'
      - If no value is specified, the the port is automatically determined
        based on the setting of eapi_protocol (http=80, https=443).
      - The value for this attribute must be in the range of 1 to 65535
    require: false
    default: null
    alias: []
"""
import syslog

from ansible.module_utils.basic import *

import pyeapi.client

COMMAND_DELAY = 3

def log(entry):
    syslog.openlog('ansible-eos')
    syslog.syslog(syslog.LOG_NOTICE, str(entry))

def get_type(name):
    if name.upper().startswith('ET'):
        return 'ethernet'
    elif name.upper().startswith('VL'):
        return 'svi'
    elif name.upper().startswith('LO'):
        return 'loopback'
    elif name.upper().startswith('PO'):
        return 'lag'
    else:
        return 'unknown'

def get_instance(node, name):
    result = node.api('interfaces').getall()
    instance = dict(name=name, state='unconfigured')
    if name in result:
        instance['state'] = 'configured'
        instance['enable'] = not result[name]['shutdown']
        instance['flowcontrol_send'] = result[name]['flowcontrol_send']
        instance['flowcontrol_receive'] = result[name]['flowcontrol_receive']
        instance['sflow'] = result[name]['sflow']
        instance['description'] = result[name]['description']
    return instance

def create_instance(node, name):
    node.api('interfaces').create(name)
    return get_instance(node, name)

def set_description(node, name, description=None, default=False, **kwargs):
    log("Invoked set_description for interface %s with value %s and default"
        "%s" % (name, description, default))
    api = node.api('interfaces')
    if default:
        return api.set_description(name, default=True)
    else:
        return api.set_description(name, description)

def set_enable(node, name, enable=None, default=False, **kwargs):
    log("Invoked set_enable for interface %s with value %s and default "
        "%s" % (name, enable, default))
    api = node.api('interfaces')
    if default:
        return api.set_shutdown(name, default=True)
    else:
        value = not enable
        return api.set_shutdown(name, value)

def set_flowcontrol_send(node, name, flowcontrol_send=None, default=None,
                         **kwargs):
    log("Invoked set_flowcontrol_send for interface %s with value %s and "
        "default %s" % (name, flowcontrol_send, default))
    api = node.api('interfaces')
    if default:
        return api.set_flowcontrol(name, 'send', default=True)
    else:
        return api.set_flowcontrol(name, 'send', flowcontrol_send)

def set_flowcontrol_receive(node, name, flowcontrol_receive=None, default=None,
                            **kwargs):
    log("Invoked set_flowcontrol_receive for interface %s with value %s and "
        "default %s" % (name, flowcontrol_receive, default))
    api = node.api('interfaces')
    if default:
        return api.set_flowcontrol(name, 'receive', default=True)
    else:
        return api.set_flowcontrol(name, 'receive',  flowcontrol_receive)

def set_sflow(node, name, sflow=None, default=False, **kwargs):
    log("Invoked set_sflow for interface %s with value %s and default %s" %\
        (name, sflow, default))
    api = node.api('interfaces')
    if default:
        return api.set_sflow(name, default=True)
    else:
        return api.set_sflow(name, sflow)

def main():

    argument_spec = dict(
        name=dict(required=True),
        enable=dict(type='bool', default=True),
        description=dict(),
        flowcontrol_send=dict(choices=['on', 'off']),
        flowcontrol_receive=dict(choices=['on', 'off']),
        sflow=dict(type='bool', default=True, choices=BOOLEANS),
        config=dict(default='/mnt/flash/eapi.conf'),
        connection=dict(default='localhost'),
        null_as_default=dict(type='bool', default=False),
        state=dict(default='configured', choices=['configured', 'unconfigured'])
    )

    module = AnsibleModule(argument_spec=argument_spec,
                           supports_check_mode=True)

    pyeapi.client.load_config(module.params['config'])
    node = pyeapi.client.connect_to(module.params['connection'])

    result = dict(changed=False, created=False, changes=dict())
    state = module.params['state']
    null_as_default = module.params['null_as_default']

    name = module.params['name']
    intftype = get_type(name)

    if intftype == 'unknown':
        module.fail_json(msg='unable to determine interface type')

    attributes = {
        'name': name,
        'enable': module.params['enable'],
        'description': module.params['description'],
        'flowcontrol_send': module.params['flowcontrol_send'],
        'flowcontrol_receive': module.params['flowcontrol_receive'],
        'sflow': module.params['sflow']
    }

    instance = get_instance(node, name)

    if state == 'configured':
        if instance is None and intftype in ['svi', 'loopback', 'lag']:
            if not module.check_mode:
                instance = create_instance(node, name)
            result['created'] = True

        changeset = attributes.viewitems() - instance.viewitems()
        for key, value in changeset:
            func = 'set_%s' % key
            if func in globals():
                command = globals().get(func)
                default = value is None and null_as_default
                if value is not None or default:
                    result['changes'][key] = value
                    result['changed'] = True
                    if not module.check_mode:
                        command(node, **attributes)

    elif instance['state'] == 'configured' and state == 'unconfigured':
        if intftype in ['svi', 'loopback', 'lag']:
            result['changed'] = True
            if not module.check_mode:
                node.module('interfaces').delete(name)
        else:
            for attr in attributes.keys():
                func = 'set_%s' % key
                if func in globals():
                    command = globals().get(func)
                    result['changed'] = True
                    if not module.check_mode:
                        command(node, **attributes)

    result['instance'] = get_instance(node, name)
    module.exit_json(**result)

main()
